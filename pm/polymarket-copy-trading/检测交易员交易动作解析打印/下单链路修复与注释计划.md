# 下单链路修复与注释计划（溢价参数化 & 可选溢价 & shares 不变）

## 0. 目标与成功判据

**目标**：把“下单（BUY/SELL）”链路的关键函数加上清晰注释（说明运行逻辑、输入输出、关键边界），并修复当前已确认的下单失败问题。

**成功判据（以日志/行为为准）**：
1. 不再出现 BUY 价格被提交为 1.0 的报错（`price (1.0), ... max: 0.999`）。
2. BUY 不再出现“提交前偷偷改 shares”的行为：
   - 代码不得用 step 向上取整 / buffer / “抬到 $1” 等方式去改变 `shares`；
   - 若在“shares 不变”的约束下无法满足服务端约束（例如 notional < $1 或服务端 min shares 更高），则必须 **跳过下单**，并在日志里明确输出 `skip_reason`（为什么跳过、需要满足什么条件）。
3. 日志中“交易员价格=1.00”的误导性输出消失（0.999 必须按更高精度打印）。
4. 溢价不再被重复计算（溢价只发生一次）。
5. 下单参数（price / shares / notional）打印能解释：
   - `planned_shares`（我们计划下单的 shares）
   - `submitted_shares`（最终提交给 CLOB 的 shares，必须与 planned_shares 一致）
   - `notional_estimated = planned_shares * price`
   - 若跳过：`skip_reason`

---

## 1. 已确认决策（来自你本次确认）

1. **溢价只发生一次**：不允许在多个阶段重复 “+0.02”。溢价作为参数传递，最终只在一个“溢价处理步骤”里生效。
2. **溢价可选**：下单逻辑需要支持“启用溢价 / 不启用溢价”两种模式；溢价处理应集中到一个独立步骤（建议封装为独立函数/步骤，但本计划文档不强绑定命名）。
3. **BUY 最小下单股数**：按服务端约束处理；当前按你确认的预期：**服务端最小允许 1 股**时就按 1 股基线执行，不再强制 5 股。
4. **shares 不变（关键约束）**：
   - 只允许通过“溢价（premium）影响 price”；
   - 不允许任何阶段（尤其是下单提交阶段）为了满足 `$1`、step、buffer 等理由去修改 shares；
   - 若 shares 固定后导致不满足服务端约束（例如 `$1` notional 或 min shares），策略应为：**跳过本次下单并打印 skip_reason**（MVP 默认），而不是偷偷改 shares。
5. **防越界规则（在溢价之后）**：
   - 先计算 `order_price = trader_price + premium`（溢价只加一次）；
   - 再做二次规则：BUY 若 `order_price > 0.99` 则改为 `0.99`；SELL 若 `order_price < 0.01` 则改为 `0.01`；
   - 最后统一做 clamp 到 `[0.001, 0.999]`（与服务端约束一致）。

---

## 2. 当前状态与仍需处理的问题（以当前代码为准）

> 说明：本节以**当前正在运行的代码基线**为准，不再复述“旧版本日志里曾经出现过但当前代码已删除/已修复”的行为。
> 目前代码整体表现接近“策略C”：溢价只加一次、价格严格 clamp 到 `[0.001, 0.999]`、不修改 shares、金额/股数不满足约束就跳过下单。

### 2.1 BUY `price=1.0` 被拒（max=0.999）
- **当前状态：已修复/已对齐**。
- 证据：
  - 定价阶段固定使用 `cap_max=0.999` 并 clamp（[`TradeExecutionService._get_current_price()`](trade_execution_service.py:523) 相关实现见 [`trade_execution_service.py`](trade_execution_service.py:655)）。
  - 提交阶段也会校验 `0.001 <= price <= 0.999`，避免提交 `1.0`（[`TradeExecutionService._place_gtc_order()`](trade_execution_service.py:1000) 相关校验见 [`trade_execution_service.py`](trade_execution_service.py:1056)）。
- **仍需确认**：文档里提到的“溢价后防越界二次规则（BUY>0.99->0.99 / SELL<0.01->0.01）”目前**尚未在代码启用**（仅写在文档里），是否要实现需要你确认（见第 4. Phase 2）。

### 2.2 “交易员价格=1.00”日志误导（0.999 显示为 1.00）
- **当前状态：部分已处理，仍需统一**。
- 已处理：下单侧价格日志已使用 `:.6f` 打印并输出 raw/controlled（[`trade_execution_service.py`](trade_execution_service.py:665)）。
- 仍存在：监控侧/展示侧仍有 `:.2f`（例如 [`MonitorService`](monitor_service.py:50) 附近的“检测到新交易”展示），会把 `0.999` 显示成 `1.00`。
- 建议（MVP）：将“价格相关展示日志”最少提升到 `:.3f`，下单链路统一 `:.6f`（避免误读）。

### 2.3 溢价重复计算（+0.02 叠加）
- **当前状态：已修复/已对齐**。
- 证据：溢价 `premium=0.02` 仅在定价阶段加一次（[`trade_execution_service.py`](trade_execution_service.py:655)），在算参阶段不再出现“二次 +0.02”的兜底逻辑（可通过全仓搜索确认）。

### 2.4 shares 被“提交前调整/向上取整/加 buffer/抬到 $1”
- **当前状态：已修复为“不修改 shares”**（策略C）。
- 证据：提交阶段 BUY 只做“提前跳过”预检，不做向上取整与 buffer（[`TradeExecutionService._place_gtc_order()`](trade_execution_service.py:1000) 的说明见 [`trade_execution_service.py`](trade_execution_service.py:1013)，并在实现中使用 `shares_floor` 仅用于预检跳过：[`trade_execution_service.py`](trade_execution_service.py:1087)）。
- 仍需确认：是否要把“预检 step=1e-4”也参数化/解释为“服务端量化假设”（目前是硬编码 1e-4）。

### 2.5 marketable BUY 的 `$1` 最小金额仍可能失败（$0.998x）
- **当前状态：策略C 会优先跳过，降低失败概率，但边界仍存在**。
- 风险原因：服务端可能在撮合/量化/费用/整数化后把名义金额压到 `< $1`。
- 最小建议（MVP，三选一，按你的“shares 不变”原则）：
  1) **更保守：提高本地预检阈值**，例如要求 `notional_floor >= 1.001` 才允许下单，否则直接跳过并输出 `skip_reason`（最少改动，但会增加跳过率）。
  2) **允许“仅提价、不改 shares”的最小补偿**：在不超过 `0.999` 的前提下，把 `price` 提升到 `min_price_to_reach_1 = 1 / shares_floor`（若可行）以抵抗量化下穿；若超出上限则跳过（需要你确认这是否算“策略变更”）。
  3) **更精确：本地模拟服务端整数化/量化规则**，让本地判断与服务端一致（工作量更大，建议放到后续）。

---

## 3. 下单链路范围（需要注释的关键函数）

### 3.1 信号来源（交易员 price / shares 生成）
- [`MonitorService.execute_trade()`](monitor_service.py:112)
- [`MonitorService._process_trade()`](monitor_service.py:323)

### 3.2 下单执行主链路（重点）
- [`TradeExecutionService.execute_copy_trade()`](trade_execution_service.py:181)
- [`TradeExecutionService._get_current_price()`](trade_execution_service.py:511)
- [`TradeExecutionService._calculate_order_params()`](trade_execution_service.py:704)
- [`TradeExecutionService._place_gtc_order()`](trade_execution_service.py:994)

---

## 4. 计划执行顺序（严格按“先注释再改逻辑”）

### Phase 1：只加注释（不改业务逻辑）
1. 为第 3 节函数增加 docstring：
   - 输入参数含义（尤其是 `signal.price/signal.shares/amount_usdc` 的来源差异）
   - 关键分支说明（BUY/SELL、市场价获取失败、余额/持仓缓存读取）
   - 输出含义与约束（price 范围、shares/notional 推导）
2. 对关键日志点加注释解释：
   - 为什么 shares 会因为 step 向上取整/缓冲而变大
   - 为什么 `signal.price` 可能来自活动里 price 或 amount/shares 推导

### Phase 2：按“溢价参数化 & 可选溢价 + shares 不变”修复逻辑（最小可行改动）
> 注：以下按“当前代码基线”标记【已完成/待确认/待实现】。

1. 价格上限/服务端约束对齐（BUY/SELL）：
   - 【已完成】clamp 区间统一为 `[0.001, 0.999]`，避免 `price=1.0` 被拒（[`trade_execution_service.py`](trade_execution_service.py:655) + [`trade_execution_service.py`](trade_execution_service.py:1056)）。
   - 【待确认】是否额外引入“策略防越界二次规则”：BUY 若 `order_price > 0.99` 则改为 `0.99`；SELL 若 `order_price < 0.01` 则改为 `0.01`。
     - 说明：当前 clamp 已保证不超过 0.999；引入 0.99 会进一步保守（可能降低成交概率/增加跳过率），需要你决定是否要。
2. 溢价参数化（且只发生一次，支持开关）：
   - 【待实现】把“溢价值（例如 0.02）”作为**参数/配置**传递，并集中在一个“溢价处理步骤”里生效（启用/禁用由开关控制）。
   - 【已完成】算参阶段不再出现“二次 +0.02”的兜底逻辑（仅保留一次溢价加法在定价阶段）。
3. shares 不变（禁止提交前调整）：
   - 【已完成】提交阶段不做 step 向上取整、buffer、或“抬到 $1”导致 shares 改变；不满足 `$1` 约束则跳过（[`trade_execution_service.py`](trade_execution_service.py:1013) + [`trade_execution_service.py`](trade_execution_service.py:1077)）。
   - 【待实现（可选）】将 step=1e-4 的“预检假设”参数化，或至少在日志中解释其来源（服务端量化假设）。
4. BUY 最小股数按服务端约束处理（不硬编码）：
   - 【已完成】当前不再强制 5 股；“卖出最小 5 股”仅作为 warning 提示（[`trade_execution_service.py`](trade_execution_service.py:748)）。
   - 【待确认】若未来遇到市场/SDK 返回更高的 min shares，MVP 默认策略仍为“跳过 + 明确提示”，是否需要做成可配置策略。
5. 统一日志精度：
   - 【部分完成】下单侧 `[PRICE]` 已使用 `:.6f`（[`trade_execution_service.py`](trade_execution_service.py:665)）。
   - 【待实现】监控/展示侧把 price 的 `:.2f` 至少提升到 `:.3f`（避免 0.999 显示成 1.00），下单链路继续保持 `:.6f`。

---

## 5. 关键输出与日志格式（用于快速验证）

建议在下单前后统一打印以下字段（并在注释里说明）：
- trader_price（来源：signal.price 或 amount/shares）
- order_price（= trader_price + premium，并做 clamp）
- planned_shares（计划下单 shares；本次约束：不得在提交阶段被修改）
- submitted_shares（最终提交 shares；必须 == planned_shares）
- notional_estimated（planned_shares * order_price）
- skip_reason（若跳过）

---

## 6. 后续建议（非本次 MVP 的强制范围，先记录）

1. 解决 `$1` notional 仍偶发失败：
   - 在“shares 不变”约束下，最稳妥的 MVP 策略是：**不满足就跳过**（并明确输出 skip_reason）。
   - 若未来允许“仅提高价格、不改 shares”（依然符合你“只做溢价”的原则），可引入“最小 notional 价格补偿”策略：在不超过 `0.999` 上限前提下轻微提高 price，抵抗整数化/费用导致的下穿；
   - 更精确方案：模拟服务端整数化（base units）并在本地保证最终 `>= 1`。
2. 市场级别约束动态获取（min shares / step）：
   - 不同市场的最小股数/步进可能不同，未来可从市场配置或 orderbook 元信息读取（若 SDK 支持），避免硬编码。
3. 修复 `ClobClient` 方法缺失：
   - 日志提示 `get_positions/get_balance` 不存在，说明 SDK 版本或封装不匹配，需要单独梳理（不在本次下单修复的 MVP 内）。
